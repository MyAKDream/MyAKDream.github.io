<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>进程同步和互斥 | MyAKDreamのBlog</title><meta name="author" content="MyAKDream"><meta name="copyright" content="MyAKDream"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程同步和互斥什么是进程同步进程具有异步性特征。进程异步：各并发执行的进程以各自独立的、不可预知的速度推进。进程同步：在多进程并发执行的环境下，通过特定机制​​协调进程间的执行顺序​​，以避免因资源竞争或协作需求导致的数据不一致或逻辑错误。 操作系统需要提供进程同步机制来解决异步问题。 什么是进程互斥进程并发需要共享资源的支持。各个并发执行的进程不可避免的需要共享一些资源（比如内存，又比如打印机、">
<meta property="og:type" content="article">
<meta property="og:title" content="进程同步和互斥">
<meta property="og:url" content="http://myakdream.com/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/index.html">
<meta property="og:site_name" content="MyAKDreamのBlog">
<meta property="og:description" content="进程同步和互斥什么是进程同步进程具有异步性特征。进程异步：各并发执行的进程以各自独立的、不可预知的速度推进。进程同步：在多进程并发执行的环境下，通过特定机制​​协调进程间的执行顺序​​，以避免因资源竞争或协作需求导致的数据不一致或逻辑错误。 操作系统需要提供进程同步机制来解决异步问题。 什么是进程互斥进程并发需要共享资源的支持。各个并发执行的进程不可避免的需要共享一些资源（比如内存，又比如打印机、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://myakdream.com/images/Opareting-System.png">
<meta property="article:published_time" content="2025-04-24T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-25T02:58:38.611Z">
<meta property="article:author" content="MyAKDream">
<meta property="article:tag" content="进程管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://myakdream.com/images/Opareting-System.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "进程同步和互斥",
  "url": "http://myakdream.com/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/",
  "image": "http://myakdream.com/images/Opareting-System.png",
  "datePublished": "2025-04-24T16:00:00.000Z",
  "dateModified": "2025-04-25T02:58:38.611Z",
  "author": [
    {
      "@type": "Person",
      "name": "MyAKDream",
      "url": "http://myakdream.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://myakdream.com/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程同步和互斥',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/images/Opareting-System.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">MyAKDreamのBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">进程同步和互斥</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">进程同步和互斥</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-24T16:00:00.000Z" title="发表于 2025-04-25 00:00:00">2025-04-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-25T02:58:38.611Z" title="更新于 2025-04-25 10:58:38">2025-04-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Basic/">Computer Basic</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Basic/Opareting-System/">Opareting System</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Computer-Basic/Opareting-System/Process-Management/">Process Management</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="进程同步和互斥"><a href="#进程同步和互斥" class="headerlink" title="进程同步和互斥"></a>进程同步和互斥</h1><h2 id="什么是进程同步"><a href="#什么是进程同步" class="headerlink" title="什么是进程同步"></a>什么是进程同步</h2><p>进程具有<strong>异步性特征</strong>。<br><strong>进程异步</strong>：各并发执行的进程以各自独立的、不可预知的速度推进。<br><strong>进程同步</strong>：在多进程并发执行的环境下，通过特定机制​​协调进程间的执行顺序​​，以避免因资源竞争或协作需求导致的数据不一致或逻辑错误。</p>
<p>操作系统需要提供<strong>进程同步机制</strong>来解决异步问题。</p>
<h2 id="什么是进程互斥"><a href="#什么是进程互斥" class="headerlink" title="什么是进程互斥"></a>什么是进程互斥</h2><p>进程并发需要共享资源的支持。各个并发执行的进程不可避免的需要共享一些资源（比如内存，又比如打印机、摄像头这样的I&#x2F;O设备）。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image.png" alt="alt text"></p>
<p>我们把一个时间段内只能有一个进程使用的资源叫做<strong>临界资源</strong>。</p>
<p>对临街资源的访问，必须互斥的进行。互斥，亦称<strong>间接制约关系</strong>。<strong>进程互斥</strong>指当一个访问某临界资源时，另外想要访问该临街资源的进程必须等待。当前访问临临界资源的进程访问结束，释放该资源后，另一个进程才能去访问临界资源。</p>
<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分：</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-1.png" alt="alt text"></p>
<p>注意：</p>
<ul>
<li>临界区是进程中访问临界资源的代码段。</li>
<li>进入区和退出区是负责实现互斥的代码段。</li>
<li>临界区也可称为<strong>临界段</strong>。</li>
</ul>
<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则。</p>
<ol>
<li>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li>
<li>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</li>
<li>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</li>
</ol>
<h2 id="进程互斥软件实现方法"><a href="#进程互斥软件实现方法" class="headerlink" title="进程互斥软件实现方法"></a>进程互斥软件实现方法</h2><h3 id="单标志法"><a href="#单标志法" class="headerlink" title="单标志法"></a>单标志法</h3><p>算法思想：两个进程在访问完临界区之后会把临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-2.png" alt="alt text"></p>
<p>举例：若<code>turn</code>的初始值为<code>0</code></p>
<ul>
<li>进程<code>P0</code>上处理机运行，在<code>while(turn != 0)</code>没有阻塞，进程<code>P0</code>访问临界资源。</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。</li>
<li>进程<code>P1</code>在<code>while(turn == 0)</code>处阻塞，不能进入临界区。</li>
<li>此时发生进程调度，进程<code>P0</code>上处理机运行，进程<code>P0</code>访问临界区资源结束。进程P0将<code>turn = 1</code>后退出。</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。</li>
<li>进程<code>P1</code>在<code>while(turn != 1)</code>没有阻塞，进程<code>P1</code>访问临界资源。</li>
</ul>
<p>该算法只能实现同一时刻最多允许一个进程访问临界区。只能按P0 -&gt; P1 -&gt; P0 -&gt; P1 -&gt; …这样轮流访问。那么虽然此时临界区空闲，但是并不允许P1访问，<strong>因此，单标志法的主要问题是：违背空闲让进原则</strong>。</p>
<h3 id="双标志先检查法"><a href="#双标志先检查法" class="headerlink" title="双标志先检查法"></a>双标志先检查法</h3><p><strong>算法思想</strong>：设置一个布尔型数组<code>flag[]</code>，数组中各个元素用来标记各进程想进入临界区的意愿，比如<code>flag[0] = ture</code>意味着<code>0</code>号进程<code>P0</code>现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code>flag[i]</code>设为<code>true</code>，之后开始访问临界区。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-3.png" alt="alt text"></p>
<p>举例：</p>
<ul>
<li>进程<code>P0</code>上处理机运行，在<code>while(flag[1])</code>没有阻塞。——执行完了①</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。进程<code>P1</code>在<code>while(flag[0])</code>没有阻塞。——执行完了⑤</li>
<li>此时发生进程调度，进程<code>P0</code>上处理机运行。进程<code>P0</code>执行<code>flag[0] = true</code>。——执行完了②</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。进程<code>P1</code>执行<code>flag[1] = true</code>。——执行完了⑥</li>
</ul>
<p>此时我们发现P1和P0进程都进入了临界区！！因此双标志先检查法的主要问题是：违反<strong>忙则等待原则</strong>。原因在于，进入区的<strong>进程</strong>和<strong>上锁</strong>两个处理不是一气呵成的。<strong>检测</strong>后，<strong>上锁</strong>前可能发生进程切换。</p>
<h3 id="双标志后检查法"><a href="#双标志后检查法" class="headerlink" title="双标志后检查法"></a>双标志后检查法</h3><p>算法思想：双标志先检查法的改版。前一个算法的问题是先<strong>检查</strong>后<strong>上锁</strong>，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。因此，人们又想到先<strong>上锁</strong>后<strong>检查</strong>的方法，来避免上述问题。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-4.png" alt="alt text"></p>
<p>举例：</p>
<ul>
<li>进程<code>P0</code>上处理机运行，执行<code>flag[0] = true</code>。——执行完了①</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。执行<code>flag[1] = true</code>。——执行完了⑤</li>
<li>此时发生进程调度，进程<code>P0</code>上处理机运行。进程<code>P0</code>在<code>while(flag[1])</code>阻塞——执行完了②</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。进程<code>P1</code>执行<code>while(flag[0])</code>。——执行完了⑥</li>
</ul>
<p>此时我们发现P1和P0进程都阻塞在临界区外面！！因此双标志后检查法虽然解决了<strong>忙则等待</strong>问题，但是违背了<strong>空闲让进</strong>和<strong>有限等待</strong>。会因个进程都长期无法访问临界资源二产生饥饿现象。两个进程都争着想进入临界区，但是谁也不让谁，最后谁都无法进入临界区。</p>
<h3 id="Peterson算法"><a href="#Peterson算法" class="headerlink" title="Peterson算法"></a>Peterson算法</h3><p>算法思想：结合双标志法、单标志法的思想。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-5.png" alt="alt text"></p>
<p>举例：</p>
<ul>
<li>进程<code>P0</code>上处理机运行，执行<code>flag[0] = true</code>。——执行完了①</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。执行<code>flag[1] = true</code>。——执行完了⑥</li>
<li>此时发生进程调度，进程<code>P0</code>上处理机运行。进程<code>P0</code>在<code>turn = 1</code>阻塞——执行完了②</li>
<li>此时发生进程调度，进程<code>P1</code>上处理机运行。进程<code>P1</code>执行<code>turn = 0</code>。——执行完了⑦</li>
<li>此时发生进程调度，进程<code>P0</code>上处理机运行。进程<code>P0</code>执行<code>while(flag[0] &amp;&amp; turn == 1)</code>进入临界区。——执行完了③</li>
<li>此时发生进程调度，进程<code>P0</code>上处理机运行。进程<code>P0</code>执行<code>while(flag[1] &amp;&amp; turn == 0)</code>阻塞在临界区之外。——执行完了⑧</li>
</ul>
<p><code>Peterson</code>算法用软件方法解决了进程互斥问题，遵循了空闲让进、忙<br>则等待、有限等待三个原则，但是依然未遵循让权等待的原则。<br><code>Peterson</code>算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>解决临界区最简单的工具就是互斥锁。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数<code>acquire()</code>获得锁，而函数<code>release()</code>释放锁。</p>
<p>每个临界区有一个布尔变量<code>available</code>，表示锁是否可用，如果可用，调用<code>acquire()</code>会成功，而锁不再可用。当一个进程获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-27.png" alt="alt text"></p>
<p><code>acquire()</code>和<code>release()</code>的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。需要连续循环忙等的互斥锁，都可称为<strong>自旋锁</strong>。</p>
<p>特性：</p>
<ul>
<li>需忙等，进程时间片用完才下处理机，违反“让权等待”</li>
<li>优点：等待期间不用切换进程上下文，多处理器系统中，若上锁的时间短，则等待代价很低</li>
<li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区</li>
<li>不太适用于单处理机系统，忙等的过程中不可能解锁</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-28.png" alt="alt text"></p>
<h2 id="进程互斥硬件实现方法"><a href="#进程互斥硬件实现方法" class="headerlink" title="进程互斥硬件实现方法"></a>进程互斥硬件实现方法</h2><h3 id="中断屏蔽方法"><a href="#中断屏蔽方法" class="headerlink" title="中断屏蔽方法"></a>中断屏蔽方法</h3><p>利用开&#x2F;关中断指令实现（与原语实现的思想相同，即在某进程开始访问临界区到访问结束为止不允许被中断，也就不允许发生进程切换，因此也不可能方式两个同时访问临界区的情况）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">开中断</span><br><span class="line">临界区</span><br><span class="line">关中断</span><br></pre></td></tr></table></figure>

<p>优点：简单、高效<br>缺点：不使用于多核处理机；只适用于操作系统内核进程，不适用于用户进程（因为开关中断指令只能运行在内核态，这组指令如果让用户随便使用会危险）</p>
<h3 id="TestAndSet指令"><a href="#TestAndSet指令" class="headerlink" title="TestAndSet指令"></a>TestAndSet指令</h3><p>简称TS指令有时也称为TestAndSetLock指令。TSL指令使用硬件实现的，执行过程中不允许被中断，只能一气呵成。以下使用C语言描述的逻辑。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-6.png" alt="alt text"></p>
<p>若刚开始lock是false，则TSL返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区。<br>若刚开始lock是true，则执行TLS后old值返回true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行解锁。</p>
<p>优点：实现简单，TSL指令把上锁和检测操作用硬件的方式变成了一气呵成的原子操作。<br>缺点：不满足<strong>让权等待</strong>原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。</p>
<h3 id="swap指令"><a href="#swap指令" class="headerlink" title="swap指令"></a>swap指令</h3><p>Swap指令时通过硬件实现的，执行的过程不允许被中断，只能一气呵成。以下使用C语言描述的逻辑。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-7.png" alt="alt text"></p>
<p>逻辑上看和<code>TSL</code>指令并没有太大区别，都是先记录下此时临界区是否已经被上锁，再将上锁标记<code>lock</code>设置为<code>true</code>，最后检查<code>old</code>，如果<code>old</code>为<code>false</code>则说明没有别的进程对临界区上锁，即可跳出循环，进入临界区。</p>
<p>优点：实现简单，无需想软件实现方法那样严格检查是否会由逻辑漏洞；适用于多处理机环境。<br>缺点：不满足<strong>让权等待</strong>原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致忙等。</p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p><strong>信号量</strong>：其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量。比如：一台打印机，就可以设置一个初值为1的信号量。<br><strong>一对原语</strong>：<code>wait(S)</code>原语和<code>signal(S)</code>原语。</p>
<p><code>wait</code>、<code>signal</code>原语常简称为P、V操作（来自荷兰语proberen和verhogen）。因此，做题的时候常把<code>wait(S)</code>、<code>signal(S)</code>两个操作分别写为<code>P(S)</code>、<code>V(S)</code></p>
<h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>用一个整数型变变量作为信号量，用来表示系统中某种资源的数量。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-8.png" alt="alt text"></p>
<p>举例：某计算机系统中有一台打印机</p>
<ul>
<li>进程P0先上处理机运行，执行了<code>wait(S)</code>原语，<code>S--</code>表示占用一个打印机资源。此时<code>S = 0</code>，表明此时没有打印机资源剩余。进程P0进入临界区使用打印机资源。</li>
<li>CPU调度进程P1上处理机运行，执行了<code>wait(S)</code>原语，检查发现<code>S = 0</code>，进程P1在<code>while(S &lt;= 0)</code>处阻塞。</li>
<li>CPU调度进程P2上处理机运行，执行了<code>wait(S)</code>原语，检查发现<code>S = 0</code>，进程P2在<code>while(S &lt;= 0)</code>处阻塞。</li>
<li>CPU调度进程P0上处理机运行，使用结束后释放打印机资源，执行了<code>signal(S)</code>原语，<code>S++</code>此时<code>S = 1</code>，表明此时有打印机资源剩余。进程P0退出。</li>
<li>CPU调度进程P1上处理机运行，执行了<code>wait(S)</code>原语，<code>S--</code>表示占用一个打印机资源。此时<code>S = 0</code>，表明此时没有打印机资源剩余。进程P1进入临界区使用打印机资源。</li>
<li>CPU调度进程P2上处理机运行，执行了<code>wait(S)</code>原语，检查发现<code>S = 0</code>，进程P2在<code>while(S &lt;= 0)</code>处阻塞。</li>
<li>CPU调度进程P1上处理机运行，使用结束后释放打印机资源，执行了<code>signal(S)</code>原语，<code>S++</code>此时<code>S = 1</code>，表明此时有打印机资源剩余。进程P1退出。</li>
<li>CPU调度进程P2上处理机运行，执行了<code>wait(S)</code>原语，<code>S--</code>表示占用一个打印机资源。此时<code>S = 0</code>，表明此时没有打印机资源剩余。进程P2进入临界区使用打印机资源。</li>
</ul>
<p>优点：检查和上锁一气呵成，避免了并发。<br>缺点：不满足<strong>让权等待</strong>原则，会发生忙等。</p>
<h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>记录型信号量是用数据结构表示的信号量。</p>
<img src="image-9.png" height="300">

<ul>
<li><code>block(S.L)</code>：如果剩余资源数不够，使用block原语使进程有运行态变为阻塞态，并挂到信号量S的等待队列中。</li>
<li><code>wakeup(S.L)</code>：释放资源后，若还有别的进程等待这种资源，则可以使用<code>wakeup</code>原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</li>
</ul>
<p>举例：某计算机系统中有<code>2</code>台计算机，则可在初始化信号<code>S</code>时将<code>S.value</code>的值设为<code>2</code>，队列<code>S.L</code>置为空。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-10.png" alt="alt text"></p>
<ul>
<li>进程P0先上处理机运行，执行了<code>wait(S)</code>原语，<code>S.value--</code>表示占用一个打印机资源。此时<code>S.value = 1</code>，表明此时有一个打印机资源剩余。</li>
<li>此时CPU调度进程P1上处理机运行，执行了<code>wait(S)</code>原语，<code>S.value--</code>表示占用一个打印机资源。此时<code>S.value = 0</code>，表明此时打印机资源已经被用完。</li>
<li>此时CPU调度进程P2上处理机运行，执行了<code>wait(S)</code>原语，<code>S.value--</code>。此时<code>S.value = -1</code>导致进程P2阻塞被挂到等待队列中。表明此时有一个进程在等待打印机资源。</li>
<li>此时CPU调度进程P3上处理机运行，执行了<code>wait(S)</code>原语，<code>S.value--</code>。此时<code>S.value = -2</code>导致进程P3阻塞被挂到等待队列中。表明此时有两个进程在等待打印机资源。</li>
<li>此时CPU调度进程P0上处理机运行，进程P0使用完打印机资源，执行了<code>signal(S)</code>原语，此时<code>S.value++</code>表示释放一个打印机资源。此时<code>S.value--</code>，表明此时还有进程在等待打印机资源。同时唤醒P2进程，进程P0退出。</li>
<li>此时CPU调度进程P1上处理机运行，进程P1使用完打印机资源，执行了<code>signal(S)</code>原语，此时<code>S.value++</code>表示释放一个打印机资源。此时<code>S.value = 0</code>，表明此时还有进程在等待打印机资源。同时唤醒P3进程，进程P1退出。</li>
<li>此时CPU调度进程P2上处理机运行，进程P1使用完打印机资源，执行了<code>signal(S)</code>原语，此时<code>S.value++</code>表示释放一个打印机资源。此时<code>S.value = 1</code>，表明此时有一个打印机资源剩余。进程P2退出。</li>
<li>此时CPU调度进程P3上处理机运行，进程P1使用完打印机资源，执行了<code>signal(S)</code>原语，此时<code>S.value++</code>表示释放一个打印机资源。此时<code>S.value = 2</code>，表明此时有两个打印机资源剩余。进程P3退出。</li>
</ul>
<p>对信号量S的一次P操作意味着进程请求一个单位的该类资源，因此需要执行<code>S.value--</code>，表示资源数减1，当<code>S.value &lt; 0</code>时表示该类资源已分配完毕，因此进程应调用block原语自我阻塞（运行态变为阻塞态），主动放弃处理机，并插入该类资源的等待队列S.L中。该机制满足<strong>让权等待</strong>原则，不会出现忙等现象。<br>对信号量S的一次V操作意味着进程释放一个单位的该类资源，因此需要执行<code>S.value++</code>，表示资源数加1，当<code>S.value &lt;= 0</code>时表示依然有进程在等待该类资源，因此应调用wakeup原语唤醒等待队列中的第一个进程（阻塞态变为就绪态）。</p>
<h2 id="线程互斥同步模型"><a href="#线程互斥同步模型" class="headerlink" title="线程互斥同步模型"></a>线程互斥同步模型</h2><h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><p>背景：系统中有一组生产者进程和消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。生产者、消费者共享一个初始为空，大小为n的缓冲区。</p>
<ul>
<li>只有缓冲区没满的时候，生产者才能把产品放入缓冲区，否则必须等待。（缓冲区没满 -&gt; 生产者生产）（同步关系）</li>
<li>只有缓冲区不空的时候，消费者才能从中取出产品，否则必须等待。（缓冲区没满 -&gt; 消费者消费）（同步关系）</li>
<li>缓冲区是临界资源，各进程必须互斥访问。（互斥关系）</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-11.png" alt="alt text"></p>
<p>我们发现消费者和生产者之间有以下关系：</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-12.png" alt="alt text"></p>
<p>我们使用以下程序解决：</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-13.png" alt="alt text"></p>
<p>对于生产者：</p>
<ul>
<li>生产者先生产一个产品，之后执行<code>P(empty)</code>检查有没有空闲缓冲区，如果有空闲缓冲区，那么就消耗一个缓冲区。否则，在<code>P(empty)</code>处阻塞。</li>
<li>生产者执行<code>P(mutex)</code>向缓冲区中写入一个产品。如果此时缓冲区被消费者使用，那么在<code>P(mutex)</code>处阻塞。</li>
<li>生产者进入临界区，将产品写入缓冲区后，执行<code>V(mutex)</code>退出，释放临界区。</li>
<li>生产者执行<code>V(full)</code>表示缓冲区中增加一个产品。</li>
</ul>
<p>对于消费者：</p>
<ul>
<li>消费者执行<code>P(full)</code>消耗一个产品</li>
<li>消费者执行<code>P(mutex)</code>向缓冲区中取出一个产品。如果此时缓冲区被生产者使用，那么在<code>P(mutex)</code>处阻塞。</li>
<li>消费者进入临界区，将产品拿出缓冲区后，执行<code>V(mutex)</code>退出，释放临界区。</li>
<li>消费者执行<code>P(full)</code>表示缓冲区中减少一个产品。</li>
</ul>
<hr>
<p><font size=5>能否改变相邻P，V操作的顺序？</font></p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-14.png" alt="alt text"></p>
<p>分析：假设此时缓冲区内已经放满产品，则<code>empty=0</code>，<code>full=n</code>。</p>
<ul>
<li>生产者先生产一个产品，执行<code>P(mutex)</code>加锁。执行<code>P(empty)</code>向缓冲区中写入一个产品。但是此时缓冲区已经满了，生产者在此阻塞，等待消费者取走缓冲区的产品。</li>
<li>消费者执行<code>P(mutex)</code>加锁，但锁已经被生产者使用了，此时消费者只能等待生产者解锁。</li>
</ul>
<p>这就造成了生产者等待消费者释放空闲缓冲区，而消费者又等待生产者是否临界区的情况，生产者和消费者循环等待被对方唤醒，出现死锁。</p>
<p>同样的，若缓冲区中没有产品，即<code>empty=n</code>，<code>full=0</code>。同样会发生死锁。</p>
<p>&#x3D;&#x3D;因此：实现互斥的P操作一定要在实现同步1P操作之后。V操作不会导致进程阻塞，因此两个V操作顺序可以互换。&#x3D;&#x3D;</p>
<hr>
<h3 id="多生产者多消费者模型"><a href="#多生产者多消费者模型" class="headerlink" title="多生产者多消费者模型"></a>多生产者多消费者模型</h3><p>背景：桌子上有一只盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。用PV操作实现上述过程。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-15.png" alt="alt text"></p>
<p>问题分析：</p>
<ul>
<li>互斥关系：对缓存区盘子的访问要互斥的执行</li>
<li>同步关系：<ul>
<li>父亲将苹果放入盘子后，女儿才能取苹果。</li>
<li>母亲将橘子放入盘子后，儿子才能取橘子。</li>
<li>只有盘子为空时，父亲或者母亲才能放入苹果。（盘子为空事件可以由女儿或者儿子触发）</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-16.png" alt="alt text"></p>
<p>对于父亲进程：</p>
<ul>
<li>父亲进程先准备一个苹果，执行<code>P(plate)</code>检查盘子是否为空，为空就阻塞。</li>
<li>父亲进程发现盘子此时不为空时，执行<code>P(mutex)</code>对盘子加锁，表示父亲现在要向这个盘子放苹果。</li>
<li>父亲进程放完苹果后退出临界区，执行<code>V(mutex)</code>释放锁。</li>
<li>执行<code>V(apple)</code>表示此时盘子中有苹果。</li>
</ul>
<p>对于母亲进程：</p>
<ul>
<li>母亲进程先准备一个橙子，执行<code>P(plate)</code>检查盘子是否为空，为空就阻塞。</li>
<li>母亲进程发现盘子此时不为空时，执行<code>P(mutex)</code>对盘子加锁，表示母亲现在要向这个盘子放橙子。</li>
<li>母亲进程放完苹果后退出临界区，执行<code>V(mutex)</code>释放锁。</li>
<li>执行<code>V(orange)</code>表示此时盘子中有橘子。</li>
</ul>
<p>对于儿子进程：</p>
<ul>
<li>儿子进程执行<code>P(apple)</code>检查盘子里面是否有苹果。如果没有苹果就在此阻塞。</li>
<li>儿子进程发现盘子里面有苹果时，执行<code>P(mutex)</code>对盘子加锁，表示儿子现在要向这个盘子取苹果。</li>
<li>儿子进程取完苹果后退出临界区，执行<code>V(mutex)</code>释放锁。</li>
<li>执行<code>V(plate)</code>表示此时盘子为空。</li>
</ul>
<p>对于女儿进程：</p>
<ul>
<li>女儿进程执行<code>P(apple)</code>检查盘子里面是否有苹果。如果没有苹果就在此阻塞。</li>
<li>女儿进程发现盘子里面有橘子时，执行<code>P(mutex)</code>对盘子加锁，表示女儿现在要向这个盘子取橘子。</li>
<li>女儿进程取完橘子后退出临界区，执行<code>V(mutex)</code>释放锁。</li>
<li>执行<code>V(plate)</code>表示此时盘子为空。</li>
</ul>
<hr>
<p><font size=5>如果不设置专门的互斥变量mutex会出现进程安全问题吗？</font></p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-17.png" alt="alt text"></p>
<p>分析：</p>
<ul>
<li>假设父亲进程先上处理机运行，准备一个苹果，执行<code>P(plate)</code>占用盘子这个临界资源。</li>
<li>此时CPU调度母亲进程上处理机运行，准备一个橘子，执行<code>P(plate)</code>发现盘子已经被占用，母亲进程阻塞。</li>
<li>此时CPU调度儿子进程上处理机运行，执行<code>P(apple)</code>发现盘子里面没有苹果。儿子进程阻塞。</li>
<li>此时CPU调度女儿进程上处理机运行，执行<code>P(orange)</code>发现盘子里面没有橘子。女儿进程阻塞。</li>
<li>此时CPU调度父亲进程上处理机运行，执行<code>V(apple)</code>将苹果放入盘子中。</li>
<li>此时CPU调度母亲进程上处理机运行，执行<code>P(plate)</code>发现盘子已经被占用，母亲进程阻塞。</li>
<li>此时CPU调度儿子进程上处理机运行，执行<code>P(apple)</code>发现盘子里面有苹果。取出苹果，执行<code>V(plate)</code>表示盘子空闲。吃掉苹果。</li>
<li>此时CPU调度女儿进程上处理机运行，执行<code>P(orange)</code>发现盘子里面没有橘子。女儿进程阻塞。</li>
</ul>
<p>我们发现依然可以实现互斥和同步，因为本题中的缓冲区大小为1，在任何时刻，<code>apple</code>、<code>orange</code>、<code>plate</code>三个同步信号量中最多只有一个是1。因此在任何时刻只有一个进程的<code>P</code>操作不会被阻塞，并顺利进入临界区。</p>
<p><font size=5>如果盘子的容量为2呢？</font></p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-18.png" alt="alt text"></p>
<p>我们发现：父亲和母亲执行<code>P(plate)</code>操作时都会进入临界区。如果不是设置一个互斥变量<code>mutex</code>，那么会导致两个进程写入缓冲区的数据相互覆盖的情况。如果缓冲区的大小大于一，就必须专门设置一个信号量<code>mutex</code>保证互斥访问临界区。</p>
<hr>
<h3 id="吸烟者问题"><a href="#吸烟者问题" class="headerlink" title="吸烟者问题"></a>吸烟者问题</h3><p>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-19.png" alt="alt text"></p>
<p>问题分析：</p>
<ul>
<li>互斥关系：桌子为如果容量为1的缓冲区，要互斥访问。但是缓冲区的容量为1，可以不用设置信号量实现互斥。</li>
<li>同步关系：<ul>
<li>桌子上有组合一：第一个抽烟者取走东西。</li>
<li>桌子上有组合二：第二个抽烟者取走东西。</li>
<li>桌子上有组合三：第三个抽烟者取走东西。</li>
<li>发出完成信号：供应者将下一个组合放到桌子上。</li>
</ul>
</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-20.png" alt="alt text"></p>
<p>对于供应者进程：</p>
<ul>
<li>通过<code>i</code>判断将哪个组合放到桌子上，如果是组合一，执行<code>V(offer1)</code>将组合<code>1</code>放到桌子上。如果是组合二，执行<code>V(offer2)</code>将组合<code>2</code>放到桌子上。如果是组合三，执行<code>V(offer3)</code>将组合<code>3</code>放到桌子上。</li>
<li>执行<code>P(finish)</code>检查抽烟者进程是否抽烟完成，不完成就在此阻塞。</li>
</ul>
<p>对于抽烟者进程1：</p>
<ul>
<li>执行<code>P(offer1)</code>检查桌子上是否是自己想要的组合，如果没有，就在此阻塞。否则就从桌子上拿走组合一，卷烟，抽掉。</li>
<li>执行<code>V(finish)</code>通知供应者进程可以继续将组合放到桌子上。</li>
</ul>
<p>对于抽烟者进程2：</p>
<ul>
<li>执行<code>P(offer2)</code>检查桌子上是否是自己想要的组合，如果没有，就在此阻塞。否则就从桌子上拿走组合二，卷烟，抽掉。</li>
<li>执行<code>V(finish)</code>通知供应者进程可以继续将组合放到桌子上。</li>
</ul>
<p>对于抽烟者进程3：</p>
<ul>
<li>执行<code>P(offer3)</code>检查桌子上是否是自己想要的组合，如果没有，就在此阻塞。否则就从桌子上拿走组合三，卷烟，抽掉。</li>
<li>执行<code>V(finish)</code>通知供应者进程可以继续将组合放到桌子上。</li>
</ul>
<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。<br>因此要求：</p>
<ul>
<li>允许多个读者可以同时对文件执行读操作；</li>
<li>只允许一个写者往文件中写信息；</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作；</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-21.png" alt="alt text"></p>
<p>问题分析：</p>
<ul>
<li>互斥关系：写进程和写进程，读进程和写进程要互斥的访问共享文件。读进程和读进程不需要互斥访问。</li>
<li>同步关系：读进程和写进程不分先后。</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-22.png" alt="alt text"></p>
<p>对于写进程：</p>
<ul>
<li>在文件之前执行<code>V(rw)</code>加锁，写完了执行<code>P(rw)</code>解锁</li>
</ul>
<p>对于读进程：使用count变量记录现在有几个读进程正在进行访问。</p>
<ul>
<li>执行<code>P(count)</code>给<code>count</code>加锁，每来一个进程读文件<code>count++</code>，第一个读进程读之前需要执行<code>P(rw)</code>对文件加锁。</li>
<li>读文件结束之后执行<code>V(rw)</code>对文件进程解锁。同时执行<code>count--</code>表示读进程减少一个。</li>
<li>当全部读进程都读完时，执行<code>V(rw)</code>释放文件读写锁。执行<code>V(count)</code>释放计数锁</li>
</ul>
<p>我们分析会发现一个问题：只要有读进程还在读写，写进程就需要一直阻塞等待，可能锁死，因此在这种算法中，读进程是优先的。</p>
<p><font size=5>改进：</font></p>
<p>我们添加一个新变量<code>w</code>实现写优先。只有当写进程写完之后，读进程才能执行写操作。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-23.png" alt="alt text"></p>
<p>对于写进程：</p>
<ul>
<li>执行<code>P(w)</code>，表示写进程优先执行。执行<code>P(rw)</code>，给文件加读写锁。</li>
<li>写进程进入临界区写文件。</li>
<li>执行<code>V(rw)</code>，释放文件读写锁，执行<code>V(w)</code>，写进程优先解锁。</li>
</ul>
<p>对于读进程：</p>
<ul>
<li>执行<code>P(w)</code>，检查写进程是否有写操作。如果有，则在此阻塞。否则，将写进程优先锁抢过来，保证读操作不会被写操作抢占。</li>
<li>执行<code>P(mutex)</code>，给<code>count</code>变量加锁，每来一个进程读文件<code>count++</code>，第一个读进程读之前需要执行<code>P(rw)</code>对文件加锁。</li>
<li>执行<code>V(w)</code>，读进程释放写进程优先锁。允许写进程写文件。</li>
<li>执行<code>P(mutex)</code>，给<code>count</code>变量加锁，读文件结束之后执行<code>V(rw)</code>对文件进程解锁。同时执行<code>count--</code>表示读进程减少一个。</li>
<li>当全部读进程都读完时，执行<code>V(rw)</code>释放文件读写锁。执行<code>V(count)</code>释放计数锁</li>
</ul>
<hr>
<p>该算法的核心思想在于设置了一个计数器<code>count</code>用来记录当前正在访问共享文件的读进程数。我们可以用<code>count</code>的值来判断当前进入的进程是否是第一个&#x2F;最后一个读进程，从而做出不同的处理。另外，对<code>count</code>变量的检查和赋值不能一气呵成导致了一些错误，如果需要实现<strong>一气呵成</strong>，自然应该想到用互斥信号量。</p>
<hr>
<h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<img src="image-24.png" height="300" width="400">

<p>问题分析：</p>
<ul>
<li>系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>信号量设置。定义互斥信号量数组<code>chopstick[5] = &#123;1, 1, 1, 1, 1&#125;</code> 用于实现对5个筷子的互斥访问。并对哲学家按<code>0 ~ 4</code>编号，哲学家 <code>i</code> 左边的筷子编号为 <code>i</code>，右边的筷子编号为<code>(i + 1) % 5</code>。</li>
</ul>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-25.png" alt="alt text"></p>
<p>每位哲学家都会先拿起左边的筷子，再拿起右边的筷子，之后再吃饭。</p>
<ul>
<li>假设哲学家0上处理机运行，哲学家0执行<code>P(chopstick[0])</code>拿起其左边的筷子。</li>
<li>此时CPU调度哲学家1上处理机运行，哲学家1执行<code>P(chopstick[1])</code>拿起其左边的筷子。</li>
<li>此时CPU调度哲学家2上处理机运行，哲学家2执行<code>P(chopstick[2])</code>拿起其左边的筷子。</li>
<li>此时CPU调度哲学家3上处理机运行，哲学家3执行<code>P(chopstick[3])</code>拿起其左边的筷子。</li>
<li>此时CPU调度哲学家4上处理机运行，哲学家4执行<code>P(chopstick[4])</code>拿起其左边的筷子。</li>
<li>此时CPU调度哲学家0上处理机运行，哲学家0执行<code>P(chopstick[0])</code>想要拿起其右边的筷子，发现此时右边的筷子已经被占用。哲学家0在此阻塞。</li>
<li>同理其他哲学家都会因为拿不到右边的筷子而阻塞。</li>
</ul>
<p>此时系统中出现了循环等待，造成了死锁！</p>
<hr>
<p><font size=5>如何避免死锁现象的发生呢？</font></p>
<ol>
<li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li>
<li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li>
<li>仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子。</li>
</ol>
<hr>
<p>我们采用第三种方法：各哲学家拿筷子这件事必须互斥的执行。这就保证了即使一个哲学家在拿筷子拿到一半时被阻塞，也不会有别的哲学家会继续尝试拿筷子。这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p>
<p><img src="/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/image-26.png" alt="alt text"></p>
<p>每位哲学家都会同时拿起左边和右边的筷子，之后再吃饭。</p>
<ul>
<li>哲学家<code>i</code>执行<code>P(mutex)</code>，表示哲学家<code>i</code>要拿筷子，如果有其他哲学家先于他拿起筷子，那么就在此阻塞。</li>
<li>哲学家<code>i</code>执行<code>P(chopstick[i])</code>和<code>P(chopstick[(i + 1) % 5])</code>拿起其左右两边的筷子。</li>
<li>执行<code>V(mutex)</code>，允许其他哲学家拿筷子，哲学家<code>i</code>拿到筷子后吃饭。</li>
<li>哲学家<code>i</code>执行<code>V(chopstick[i])</code>和<code>P(chopstick[(i + 1) % 5])</code>释放其左右两边的筷子。开始思考。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://MyAKDream.com">MyAKDream</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://myakdream.com/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/">http://myakdream.com/2025/04/25/Opareting%20System/Process%20Management/Process%20synchronization/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://MyAKDream.com" target="_blank">MyAKDreamのBlog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">进程管理</a></div><div class="post-share"><div class="social-share" data-image="/images/Opareting-System.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/04/25/Opareting%20System/Process%20Management/Process%20Overview/" title="进程概述"><img class="cover" src="/images/Opareting-System.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">进程概述</div></div><div class="info-2"><div class="info-item-1">进程概述概念进程（Process）是程序关于某数据集合的一次运行活动，由程序代码、数据及进程控制块（PCB）组成。它不仅是系统资源（如内存、文件、CPU时间）的分配单元，也是并发执行的基本实体。  程序：静态的，就存放在磁盘里的可执行文件，如QQ.exe。 进程：动态的，是程序的一次执行过程，如同时执行多次QQ程序。  同一个程序多次执行会对应多个进程。 进程的组成PCB当一个进程被创建时，操作系统产生一个对应数据结构：PCB(Process Control...</div></div></div></a><a class="pagination-related" href="/2025/04/25/Javascript/Basic%20grammer/Async_Await/" title="Async和Await"><img class="cover" src="/images/JavaScript.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Async和Await</div></div><div class="info-2"><div class="info-item-1">Async和Await概述在JavaScript中，async 和 await 是用于处理异步操作的关键字，它们提供了一种更简洁和易于理解的方式来编写异步代码。与传统的回调函数和Promise相比，async 和 await 使异步代码看起来更像是同步代码，从而提高了代码的可读性和维护性。 async 关键字async 关键字用于声明一个异步函数。这个函数会隐式地返回一个Promise对象。即使你没有在函数内部显式地返回一个Promise，JavaScript引擎也会自动将函数的返回值包装成一个Promise。 123async function myAsyncFunction() &#123;  // 这里可以包含同步和异步操作&#125;  await 关键字await...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/04/29/Opareting%20System/Process%20Management/Deadlock/" title="死锁"><img class="cover" src="/images/Opareting-System.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">死锁</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/04/16/Opareting%20System/Process%20Management/Process%20Communication/" title="进程通信"><img class="cover" src="/images/Opareting-System.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="info-item-2">进程通信</div></div><div class="info-2"><div class="info-item-1">进程通信概述进程间通信（IPC）是指两个进程之间产生数据交互。 为什么进程需要操作系统支持进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。 为了保证安全，一个进程不能直接访问另一个进程的地址空间。  共享存储为了避免出错。各个进程对共享空间的访问应该是互斥的。各个进程可使用的操作系统内核提供的同步互斥工具。（如P，V操作）  共享存储分为基于数据结构的共享：  基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信方式。 基于存储区的共享：操作系统在内存中划出一块共享存储区，数据的形式，存放的位置都由通信进程控制，而不是操作系统。这种共享方式的速度很快，是一种高级通信方式。  消息传递进程间的数据交换以格式化的信息为单位。进程通过操作系统提供的发送消息&#x2F;接收消息两个原语进行数据交换。  直接通信方式 进程P向进程Q直接发送消息：  进程P先将向进程Q发送的数据封装为一个Message 进程P执行发送原语：Send(Q,...</div></div></div></a><a class="pagination-related" href="/2025/04/25/Opareting%20System/Process%20Management/Process%20Overview/" title="进程概述"><img class="cover" src="/images/Opareting-System.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-25</div><div class="info-item-2">进程概述</div></div><div class="info-2"><div class="info-item-1">进程概述概念进程（Process）是程序关于某数据集合的一次运行活动，由程序代码、数据及进程控制块（PCB）组成。它不仅是系统资源（如内存、文件、CPU时间）的分配单元，也是并发执行的基本实体。  程序：静态的，就存放在磁盘里的可执行文件，如QQ.exe。 进程：动态的，是程序的一次执行过程，如同时执行多次QQ程序。  同一个程序多次执行会对应多个进程。 进程的组成PCB当一个进程被创建时，操作系统产生一个对应数据结构：PCB(Process Control...</div></div></div></a><a class="pagination-related" href="/2025/04/29/Opareting%20System/Process%20Management/Management%20Process/" title="管程"><img class="cover" src="/images/Opareting-System.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">管程</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/04/16/Opareting%20System/Process%20Management/Process%20control/" title="进程控制"><img class="cover" src="/images/Opareting-System.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-16</div><div class="info-item-2">进程控制</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a><a class="pagination-related" href="/2025/04/29/Opareting%20System/Process%20Management/Thread/" title="线程"><img class="cover" src="/images/Opareting-System.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-29</div><div class="info-item-2">线程</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/favicon.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">MyAKDream</div><div class="author-info-description">Computer Science Note By MyAKDream</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">64</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-number">1.</span> <span class="toc-text">进程同步和互斥</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.1.</span> <span class="toc-text">什么是进程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5"><span class="toc-number">1.2.</span> <span class="toc-text">什么是进程互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">进程互斥软件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">单标志法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%85%88%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">双标志先检查法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95"><span class="toc-number">1.3.3.</span> <span class="toc-text">双标志后检查法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">Peterson算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">1.3.5.</span> <span class="toc-text">互斥锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">进程互斥硬件实现方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%B1%8F%E8%94%BD%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">中断屏蔽方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TestAndSet%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.2.</span> <span class="toc-text">TestAndSet指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swap%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.3.</span> <span class="toc-text">swap指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">信号量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">整型信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%9E%8B%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">记录型信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.</span> <span class="toc-text">线程互斥同步模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">生产者消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.6.2.</span> <span class="toc-text">多生产者多消费者模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">吸烟者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.4.</span> <span class="toc-text">读者写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.5.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/30/Opareting%20System/Memory%20management/Memory%20Space%20Overcharge/" title="内存空间的拓充"><img src="/images/Opareting-System.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内存空间的拓充"/></a><div class="content"><a class="title" href="/2025/04/30/Opareting%20System/Memory%20management/Memory%20Space%20Overcharge/" title="内存空间的拓充">内存空间的拓充</a><time datetime="2025-04-29T16:00:00.000Z" title="发表于 2025-04-30 00:00:00">2025-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/30/Opareting%20System/Memory%20management/Summarize/" title="内存概述"><img src="/images/Opareting-System.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内存概述"/></a><div class="content"><a class="title" href="/2025/04/30/Opareting%20System/Memory%20management/Summarize/" title="内存概述">内存概述</a><time datetime="2025-04-29T16:00:00.000Z" title="发表于 2025-04-30 00:00:00">2025-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/29/Opareting%20System/Process%20Management/Deadlock/" title="死锁"><img src="/images/Opareting-System.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="死锁"/></a><div class="content"><a class="title" href="/2025/04/29/Opareting%20System/Process%20Management/Deadlock/" title="死锁">死锁</a><time datetime="2025-04-28T16:00:00.000Z" title="发表于 2025-04-29 00:00:00">2025-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/29/Opareting%20System/Process%20Management/Management%20Process/" title="管程"><img src="/images/Opareting-System.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="管程"/></a><div class="content"><a class="title" href="/2025/04/29/Opareting%20System/Process%20Management/Management%20Process/" title="管程">管程</a><time datetime="2025-04-28T16:00:00.000Z" title="发表于 2025-04-29 00:00:00">2025-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/29/Opareting%20System/Process%20Management/Thread/" title="线程"><img src="/images/Opareting-System.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="线程"/></a><div class="content"><a class="title" href="/2025/04/29/Opareting%20System/Process%20Management/Thread/" title="线程">线程</a><time datetime="2025-04-28T16:00:00.000Z" title="发表于 2025-04-29 00:00:00">2025-04-29</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By MyAKDream</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.0-b1</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>